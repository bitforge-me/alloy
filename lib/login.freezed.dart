// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'login.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$LoginChoice {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() doLogin,
    required TResult Function() doRegistration,
    required TResult Function() doApiKeyRequest,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? doLogin,
    TResult? Function()? doRegistration,
    TResult? Function()? doApiKeyRequest,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? doLogin,
    TResult Function()? doRegistration,
    TResult Function()? doApiKeyRequest,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LCDoLogin value) doLogin,
    required TResult Function(LCDoRegistration value) doRegistration,
    required TResult Function(LCDApiKeyRequest value) doApiKeyRequest,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LCDoLogin value)? doLogin,
    TResult? Function(LCDoRegistration value)? doRegistration,
    TResult? Function(LCDApiKeyRequest value)? doApiKeyRequest,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LCDoLogin value)? doLogin,
    TResult Function(LCDoRegistration value)? doRegistration,
    TResult Function(LCDApiKeyRequest value)? doApiKeyRequest,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginChoiceCopyWith<$Res> {
  factory $LoginChoiceCopyWith(
          LoginChoice value, $Res Function(LoginChoice) then) =
      _$LoginChoiceCopyWithImpl<$Res, LoginChoice>;
}

/// @nodoc
class _$LoginChoiceCopyWithImpl<$Res, $Val extends LoginChoice>
    implements $LoginChoiceCopyWith<$Res> {
  _$LoginChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LCDoLoginCopyWith<$Res> {
  factory _$$LCDoLoginCopyWith(
          _$LCDoLogin value, $Res Function(_$LCDoLogin) then) =
      __$$LCDoLoginCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LCDoLoginCopyWithImpl<$Res>
    extends _$LoginChoiceCopyWithImpl<$Res, _$LCDoLogin>
    implements _$$LCDoLoginCopyWith<$Res> {
  __$$LCDoLoginCopyWithImpl(
      _$LCDoLogin _value, $Res Function(_$LCDoLogin) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LCDoLogin implements LCDoLogin {
  const _$LCDoLogin();

  @override
  String toString() {
    return 'LoginChoice.doLogin()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LCDoLogin);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() doLogin,
    required TResult Function() doRegistration,
    required TResult Function() doApiKeyRequest,
  }) {
    return doLogin();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? doLogin,
    TResult? Function()? doRegistration,
    TResult? Function()? doApiKeyRequest,
  }) {
    return doLogin?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? doLogin,
    TResult Function()? doRegistration,
    TResult Function()? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doLogin != null) {
      return doLogin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LCDoLogin value) doLogin,
    required TResult Function(LCDoRegistration value) doRegistration,
    required TResult Function(LCDApiKeyRequest value) doApiKeyRequest,
  }) {
    return doLogin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LCDoLogin value)? doLogin,
    TResult? Function(LCDoRegistration value)? doRegistration,
    TResult? Function(LCDApiKeyRequest value)? doApiKeyRequest,
  }) {
    return doLogin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LCDoLogin value)? doLogin,
    TResult Function(LCDoRegistration value)? doRegistration,
    TResult Function(LCDApiKeyRequest value)? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doLogin != null) {
      return doLogin(this);
    }
    return orElse();
  }
}

abstract class LCDoLogin implements LoginChoice {
  const factory LCDoLogin() = _$LCDoLogin;
}

/// @nodoc
abstract class _$$LCDoRegistrationCopyWith<$Res> {
  factory _$$LCDoRegistrationCopyWith(
          _$LCDoRegistration value, $Res Function(_$LCDoRegistration) then) =
      __$$LCDoRegistrationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LCDoRegistrationCopyWithImpl<$Res>
    extends _$LoginChoiceCopyWithImpl<$Res, _$LCDoRegistration>
    implements _$$LCDoRegistrationCopyWith<$Res> {
  __$$LCDoRegistrationCopyWithImpl(
      _$LCDoRegistration _value, $Res Function(_$LCDoRegistration) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LCDoRegistration implements LCDoRegistration {
  const _$LCDoRegistration();

  @override
  String toString() {
    return 'LoginChoice.doRegistration()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LCDoRegistration);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() doLogin,
    required TResult Function() doRegistration,
    required TResult Function() doApiKeyRequest,
  }) {
    return doRegistration();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? doLogin,
    TResult? Function()? doRegistration,
    TResult? Function()? doApiKeyRequest,
  }) {
    return doRegistration?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? doLogin,
    TResult Function()? doRegistration,
    TResult Function()? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doRegistration != null) {
      return doRegistration();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LCDoLogin value) doLogin,
    required TResult Function(LCDoRegistration value) doRegistration,
    required TResult Function(LCDApiKeyRequest value) doApiKeyRequest,
  }) {
    return doRegistration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LCDoLogin value)? doLogin,
    TResult? Function(LCDoRegistration value)? doRegistration,
    TResult? Function(LCDApiKeyRequest value)? doApiKeyRequest,
  }) {
    return doRegistration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LCDoLogin value)? doLogin,
    TResult Function(LCDoRegistration value)? doRegistration,
    TResult Function(LCDApiKeyRequest value)? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doRegistration != null) {
      return doRegistration(this);
    }
    return orElse();
  }
}

abstract class LCDoRegistration implements LoginChoice {
  const factory LCDoRegistration() = _$LCDoRegistration;
}

/// @nodoc
abstract class _$$LCDApiKeyRequestCopyWith<$Res> {
  factory _$$LCDApiKeyRequestCopyWith(
          _$LCDApiKeyRequest value, $Res Function(_$LCDApiKeyRequest) then) =
      __$$LCDApiKeyRequestCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LCDApiKeyRequestCopyWithImpl<$Res>
    extends _$LoginChoiceCopyWithImpl<$Res, _$LCDApiKeyRequest>
    implements _$$LCDApiKeyRequestCopyWith<$Res> {
  __$$LCDApiKeyRequestCopyWithImpl(
      _$LCDApiKeyRequest _value, $Res Function(_$LCDApiKeyRequest) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LCDApiKeyRequest implements LCDApiKeyRequest {
  const _$LCDApiKeyRequest();

  @override
  String toString() {
    return 'LoginChoice.doApiKeyRequest()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LCDApiKeyRequest);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() doLogin,
    required TResult Function() doRegistration,
    required TResult Function() doApiKeyRequest,
  }) {
    return doApiKeyRequest();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? doLogin,
    TResult? Function()? doRegistration,
    TResult? Function()? doApiKeyRequest,
  }) {
    return doApiKeyRequest?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? doLogin,
    TResult Function()? doRegistration,
    TResult Function()? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doApiKeyRequest != null) {
      return doApiKeyRequest();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LCDoLogin value) doLogin,
    required TResult Function(LCDoRegistration value) doRegistration,
    required TResult Function(LCDApiKeyRequest value) doApiKeyRequest,
  }) {
    return doApiKeyRequest(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LCDoLogin value)? doLogin,
    TResult? Function(LCDoRegistration value)? doRegistration,
    TResult? Function(LCDApiKeyRequest value)? doApiKeyRequest,
  }) {
    return doApiKeyRequest?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LCDoLogin value)? doLogin,
    TResult Function(LCDoRegistration value)? doRegistration,
    TResult Function(LCDApiKeyRequest value)? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doApiKeyRequest != null) {
      return doApiKeyRequest(this);
    }
    return orElse();
  }
}

abstract class LCDApiKeyRequest implements LoginChoice {
  const factory LCDApiKeyRequest() = _$LCDApiKeyRequest;
}

/// @nodoc
mixin _$LoginResult {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginResultCopyWith<$Res> {
  factory $LoginResultCopyWith(
          LoginResult value, $Res Function(LoginResult) then) =
      _$LoginResultCopyWithImpl<$Res, LoginResult>;
}

/// @nodoc
class _$LoginResultCopyWithImpl<$Res, $Val extends LoginResult>
    implements $LoginResultCopyWith<$Res> {
  _$LoginResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LRChooseCopyWith<$Res> {
  factory _$$LRChooseCopyWith(
          _$LRChoose value, $Res Function(_$LRChoose) then) =
      __$$LRChooseCopyWithImpl<$Res>;
  @useResult
  $Res call({LoginChoice choice});

  $LoginChoiceCopyWith<$Res> get choice;
}

/// @nodoc
class __$$LRChooseCopyWithImpl<$Res>
    extends _$LoginResultCopyWithImpl<$Res, _$LRChoose>
    implements _$$LRChooseCopyWith<$Res> {
  __$$LRChooseCopyWithImpl(_$LRChoose _value, $Res Function(_$LRChoose) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? choice = null,
  }) {
    return _then(_$LRChoose(
      null == choice
          ? _value.choice
          : choice // ignore: cast_nullable_to_non_nullable
              as LoginChoice,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LoginChoiceCopyWith<$Res> get choice {
    return $LoginChoiceCopyWith<$Res>(_value.choice, (value) {
      return _then(_value.copyWith(choice: value));
    });
  }
}

/// @nodoc

class _$LRChoose implements LRChoose {
  const _$LRChoose(this.choice);

  @override
  final LoginChoice choice;

  @override
  String toString() {
    return 'LoginResult.choose(choice: $choice)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LRChoose &&
            (identical(other.choice, choice) || other.choice == choice));
  }

  @override
  int get hashCode => Object.hash(runtimeType, choice);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LRChooseCopyWith<_$LRChoose> get copyWith =>
      __$$LRChooseCopyWithImpl<_$LRChoose>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) {
    return choose(choice);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) {
    return choose?.call(choice);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) {
    if (choose != null) {
      return choose(choice);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) {
    return choose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) {
    return choose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) {
    if (choose != null) {
      return choose(this);
    }
    return orElse();
  }
}

abstract class LRChoose implements LoginResult {
  const factory LRChoose(final LoginChoice choice) = _$LRChoose;

  LoginChoice get choice;
  @JsonKey(ignore: true)
  _$$LRChooseCopyWith<_$LRChoose> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LRAcctCopyWith<$Res> {
  factory _$$LRAcctCopyWith(_$LRAcct value, $Res Function(_$LRAcct) then) =
      __$$LRAcctCopyWithImpl<$Res>;
  @useResult
  $Res call({Acct acct});
}

/// @nodoc
class __$$LRAcctCopyWithImpl<$Res>
    extends _$LoginResultCopyWithImpl<$Res, _$LRAcct>
    implements _$$LRAcctCopyWith<$Res> {
  __$$LRAcctCopyWithImpl(_$LRAcct _value, $Res Function(_$LRAcct) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? acct = null,
  }) {
    return _then(_$LRAcct(
      null == acct
          ? _value.acct
          : acct // ignore: cast_nullable_to_non_nullable
              as Acct,
    ));
  }
}

/// @nodoc

class _$LRAcct implements LRAcct {
  const _$LRAcct(this.acct);

  @override
  final Acct acct;

  @override
  String toString() {
    return 'LoginResult.acct(acct: $acct)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LRAcct &&
            (identical(other.acct, acct) || other.acct == acct));
  }

  @override
  int get hashCode => Object.hash(runtimeType, acct);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LRAcctCopyWith<_$LRAcct> get copyWith =>
      __$$LRAcctCopyWithImpl<_$LRAcct>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) {
    return acct(this.acct);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) {
    return acct?.call(this.acct);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) {
    if (acct != null) {
      return acct(this.acct);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) {
    return acct(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) {
    return acct?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) {
    if (acct != null) {
      return acct(this);
    }
    return orElse();
  }
}

abstract class LRAcct implements LoginResult {
  const factory LRAcct(final Acct acct) = _$LRAcct;

  Acct get acct;
  @JsonKey(ignore: true)
  _$$LRAcctCopyWith<_$LRAcct> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LRResetCopyWith<$Res> {
  factory _$$LRResetCopyWith(_$LRReset value, $Res Function(_$LRReset) then) =
      __$$LRResetCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LRResetCopyWithImpl<$Res>
    extends _$LoginResultCopyWithImpl<$Res, _$LRReset>
    implements _$$LRResetCopyWith<$Res> {
  __$$LRResetCopyWithImpl(_$LRReset _value, $Res Function(_$LRReset) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LRReset implements LRReset {
  const _$LRReset();

  @override
  String toString() {
    return 'LoginResult.reset()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LRReset);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) {
    return reset();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) {
    return reset?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) {
    return reset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) {
    return reset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(this);
    }
    return orElse();
  }
}

abstract class LRReset implements LoginResult {
  const factory LRReset() = _$LRReset;
}

/// @nodoc
abstract class _$$LRRetryCopyWith<$Res> {
  factory _$$LRRetryCopyWith(_$LRRetry value, $Res Function(_$LRRetry) then) =
      __$$LRRetryCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LRRetryCopyWithImpl<$Res>
    extends _$LoginResultCopyWithImpl<$Res, _$LRRetry>
    implements _$$LRRetryCopyWith<$Res> {
  __$$LRRetryCopyWithImpl(_$LRRetry _value, $Res Function(_$LRRetry) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LRRetry implements LRRetry {
  const _$LRRetry();

  @override
  String toString() {
    return 'LoginResult.retry()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LRRetry);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) {
    return retry();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) {
    return retry?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) {
    if (retry != null) {
      return retry();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) {
    return retry(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) {
    return retry?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) {
    if (retry != null) {
      return retry(this);
    }
    return orElse();
  }
}

abstract class LRRetry implements LoginResult {
  const factory LRRetry() = _$LRRetry;
}

/// @nodoc
abstract class _$$LRNothingCopyWith<$Res> {
  factory _$$LRNothingCopyWith(
          _$LRNothing value, $Res Function(_$LRNothing) then) =
      __$$LRNothingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LRNothingCopyWithImpl<$Res>
    extends _$LoginResultCopyWithImpl<$Res, _$LRNothing>
    implements _$$LRNothingCopyWith<$Res> {
  __$$LRNothingCopyWithImpl(
      _$LRNothing _value, $Res Function(_$LRNothing) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LRNothing implements LRNothing {
  const _$LRNothing();

  @override
  String toString() {
    return 'LoginResult.nothing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LRNothing);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) {
    return nothing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) {
    return nothing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) {
    if (nothing != null) {
      return nothing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) {
    return nothing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) {
    return nothing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) {
    if (nothing != null) {
      return nothing(this);
    }
    return orElse();
  }
}

abstract class LRNothing implements LoginResult {
  const factory LRNothing() = _$LRNothing;
}
