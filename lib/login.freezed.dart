// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'login.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$LoginChoice {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() doLogin,
    required TResult Function() doRegistration,
    required TResult Function() doApiKeyRequest,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? doLogin,
    TResult? Function()? doRegistration,
    TResult? Function()? doApiKeyRequest,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? doLogin,
    TResult Function()? doRegistration,
    TResult Function()? doApiKeyRequest,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LCDoLogin value) doLogin,
    required TResult Function(LCDoRegistration value) doRegistration,
    required TResult Function(LCDApiKeyRequest value) doApiKeyRequest,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LCDoLogin value)? doLogin,
    TResult? Function(LCDoRegistration value)? doRegistration,
    TResult? Function(LCDApiKeyRequest value)? doApiKeyRequest,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LCDoLogin value)? doLogin,
    TResult Function(LCDoRegistration value)? doRegistration,
    TResult Function(LCDApiKeyRequest value)? doApiKeyRequest,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginChoiceCopyWith<$Res> {
  factory $LoginChoiceCopyWith(
          LoginChoice value, $Res Function(LoginChoice) then) =
      _$LoginChoiceCopyWithImpl<$Res, LoginChoice>;
}

/// @nodoc
class _$LoginChoiceCopyWithImpl<$Res, $Val extends LoginChoice>
    implements $LoginChoiceCopyWith<$Res> {
  _$LoginChoiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LCDoLoginImplCopyWith<$Res> {
  factory _$$LCDoLoginImplCopyWith(
          _$LCDoLoginImpl value, $Res Function(_$LCDoLoginImpl) then) =
      __$$LCDoLoginImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LCDoLoginImplCopyWithImpl<$Res>
    extends _$LoginChoiceCopyWithImpl<$Res, _$LCDoLoginImpl>
    implements _$$LCDoLoginImplCopyWith<$Res> {
  __$$LCDoLoginImplCopyWithImpl(
      _$LCDoLoginImpl _value, $Res Function(_$LCDoLoginImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LCDoLoginImpl implements LCDoLogin {
  const _$LCDoLoginImpl();

  @override
  String toString() {
    return 'LoginChoice.doLogin()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LCDoLoginImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() doLogin,
    required TResult Function() doRegistration,
    required TResult Function() doApiKeyRequest,
  }) {
    return doLogin();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? doLogin,
    TResult? Function()? doRegistration,
    TResult? Function()? doApiKeyRequest,
  }) {
    return doLogin?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? doLogin,
    TResult Function()? doRegistration,
    TResult Function()? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doLogin != null) {
      return doLogin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LCDoLogin value) doLogin,
    required TResult Function(LCDoRegistration value) doRegistration,
    required TResult Function(LCDApiKeyRequest value) doApiKeyRequest,
  }) {
    return doLogin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LCDoLogin value)? doLogin,
    TResult? Function(LCDoRegistration value)? doRegistration,
    TResult? Function(LCDApiKeyRequest value)? doApiKeyRequest,
  }) {
    return doLogin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LCDoLogin value)? doLogin,
    TResult Function(LCDoRegistration value)? doRegistration,
    TResult Function(LCDApiKeyRequest value)? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doLogin != null) {
      return doLogin(this);
    }
    return orElse();
  }
}

abstract class LCDoLogin implements LoginChoice {
  const factory LCDoLogin() = _$LCDoLoginImpl;
}

/// @nodoc
abstract class _$$LCDoRegistrationImplCopyWith<$Res> {
  factory _$$LCDoRegistrationImplCopyWith(_$LCDoRegistrationImpl value,
          $Res Function(_$LCDoRegistrationImpl) then) =
      __$$LCDoRegistrationImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LCDoRegistrationImplCopyWithImpl<$Res>
    extends _$LoginChoiceCopyWithImpl<$Res, _$LCDoRegistrationImpl>
    implements _$$LCDoRegistrationImplCopyWith<$Res> {
  __$$LCDoRegistrationImplCopyWithImpl(_$LCDoRegistrationImpl _value,
      $Res Function(_$LCDoRegistrationImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LCDoRegistrationImpl implements LCDoRegistration {
  const _$LCDoRegistrationImpl();

  @override
  String toString() {
    return 'LoginChoice.doRegistration()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LCDoRegistrationImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() doLogin,
    required TResult Function() doRegistration,
    required TResult Function() doApiKeyRequest,
  }) {
    return doRegistration();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? doLogin,
    TResult? Function()? doRegistration,
    TResult? Function()? doApiKeyRequest,
  }) {
    return doRegistration?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? doLogin,
    TResult Function()? doRegistration,
    TResult Function()? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doRegistration != null) {
      return doRegistration();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LCDoLogin value) doLogin,
    required TResult Function(LCDoRegistration value) doRegistration,
    required TResult Function(LCDApiKeyRequest value) doApiKeyRequest,
  }) {
    return doRegistration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LCDoLogin value)? doLogin,
    TResult? Function(LCDoRegistration value)? doRegistration,
    TResult? Function(LCDApiKeyRequest value)? doApiKeyRequest,
  }) {
    return doRegistration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LCDoLogin value)? doLogin,
    TResult Function(LCDoRegistration value)? doRegistration,
    TResult Function(LCDApiKeyRequest value)? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doRegistration != null) {
      return doRegistration(this);
    }
    return orElse();
  }
}

abstract class LCDoRegistration implements LoginChoice {
  const factory LCDoRegistration() = _$LCDoRegistrationImpl;
}

/// @nodoc
abstract class _$$LCDApiKeyRequestImplCopyWith<$Res> {
  factory _$$LCDApiKeyRequestImplCopyWith(_$LCDApiKeyRequestImpl value,
          $Res Function(_$LCDApiKeyRequestImpl) then) =
      __$$LCDApiKeyRequestImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LCDApiKeyRequestImplCopyWithImpl<$Res>
    extends _$LoginChoiceCopyWithImpl<$Res, _$LCDApiKeyRequestImpl>
    implements _$$LCDApiKeyRequestImplCopyWith<$Res> {
  __$$LCDApiKeyRequestImplCopyWithImpl(_$LCDApiKeyRequestImpl _value,
      $Res Function(_$LCDApiKeyRequestImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LCDApiKeyRequestImpl implements LCDApiKeyRequest {
  const _$LCDApiKeyRequestImpl();

  @override
  String toString() {
    return 'LoginChoice.doApiKeyRequest()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LCDApiKeyRequestImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() doLogin,
    required TResult Function() doRegistration,
    required TResult Function() doApiKeyRequest,
  }) {
    return doApiKeyRequest();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? doLogin,
    TResult? Function()? doRegistration,
    TResult? Function()? doApiKeyRequest,
  }) {
    return doApiKeyRequest?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? doLogin,
    TResult Function()? doRegistration,
    TResult Function()? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doApiKeyRequest != null) {
      return doApiKeyRequest();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LCDoLogin value) doLogin,
    required TResult Function(LCDoRegistration value) doRegistration,
    required TResult Function(LCDApiKeyRequest value) doApiKeyRequest,
  }) {
    return doApiKeyRequest(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LCDoLogin value)? doLogin,
    TResult? Function(LCDoRegistration value)? doRegistration,
    TResult? Function(LCDApiKeyRequest value)? doApiKeyRequest,
  }) {
    return doApiKeyRequest?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LCDoLogin value)? doLogin,
    TResult Function(LCDoRegistration value)? doRegistration,
    TResult Function(LCDApiKeyRequest value)? doApiKeyRequest,
    required TResult orElse(),
  }) {
    if (doApiKeyRequest != null) {
      return doApiKeyRequest(this);
    }
    return orElse();
  }
}

abstract class LCDApiKeyRequest implements LoginChoice {
  const factory LCDApiKeyRequest() = _$LCDApiKeyRequestImpl;
}

/// @nodoc
mixin _$LoginResult {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginResultCopyWith<$Res> {
  factory $LoginResultCopyWith(
          LoginResult value, $Res Function(LoginResult) then) =
      _$LoginResultCopyWithImpl<$Res, LoginResult>;
}

/// @nodoc
class _$LoginResultCopyWithImpl<$Res, $Val extends LoginResult>
    implements $LoginResultCopyWith<$Res> {
  _$LoginResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LRChooseImplCopyWith<$Res> {
  factory _$$LRChooseImplCopyWith(
          _$LRChooseImpl value, $Res Function(_$LRChooseImpl) then) =
      __$$LRChooseImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LoginChoice choice});

  $LoginChoiceCopyWith<$Res> get choice;
}

/// @nodoc
class __$$LRChooseImplCopyWithImpl<$Res>
    extends _$LoginResultCopyWithImpl<$Res, _$LRChooseImpl>
    implements _$$LRChooseImplCopyWith<$Res> {
  __$$LRChooseImplCopyWithImpl(
      _$LRChooseImpl _value, $Res Function(_$LRChooseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? choice = null,
  }) {
    return _then(_$LRChooseImpl(
      null == choice
          ? _value.choice
          : choice // ignore: cast_nullable_to_non_nullable
              as LoginChoice,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LoginChoiceCopyWith<$Res> get choice {
    return $LoginChoiceCopyWith<$Res>(_value.choice, (value) {
      return _then(_value.copyWith(choice: value));
    });
  }
}

/// @nodoc

class _$LRChooseImpl implements LRChoose {
  const _$LRChooseImpl(this.choice);

  @override
  final LoginChoice choice;

  @override
  String toString() {
    return 'LoginResult.choose(choice: $choice)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LRChooseImpl &&
            (identical(other.choice, choice) || other.choice == choice));
  }

  @override
  int get hashCode => Object.hash(runtimeType, choice);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LRChooseImplCopyWith<_$LRChooseImpl> get copyWith =>
      __$$LRChooseImplCopyWithImpl<_$LRChooseImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) {
    return choose(choice);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) {
    return choose?.call(choice);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) {
    if (choose != null) {
      return choose(choice);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) {
    return choose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) {
    return choose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) {
    if (choose != null) {
      return choose(this);
    }
    return orElse();
  }
}

abstract class LRChoose implements LoginResult {
  const factory LRChoose(final LoginChoice choice) = _$LRChooseImpl;

  LoginChoice get choice;
  @JsonKey(ignore: true)
  _$$LRChooseImplCopyWith<_$LRChooseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LRAcctImplCopyWith<$Res> {
  factory _$$LRAcctImplCopyWith(
          _$LRAcctImpl value, $Res Function(_$LRAcctImpl) then) =
      __$$LRAcctImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Acct acct});
}

/// @nodoc
class __$$LRAcctImplCopyWithImpl<$Res>
    extends _$LoginResultCopyWithImpl<$Res, _$LRAcctImpl>
    implements _$$LRAcctImplCopyWith<$Res> {
  __$$LRAcctImplCopyWithImpl(
      _$LRAcctImpl _value, $Res Function(_$LRAcctImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? acct = null,
  }) {
    return _then(_$LRAcctImpl(
      null == acct
          ? _value.acct
          : acct // ignore: cast_nullable_to_non_nullable
              as Acct,
    ));
  }
}

/// @nodoc

class _$LRAcctImpl implements LRAcct {
  const _$LRAcctImpl(this.acct);

  @override
  final Acct acct;

  @override
  String toString() {
    return 'LoginResult.acct(acct: $acct)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LRAcctImpl &&
            (identical(other.acct, acct) || other.acct == acct));
  }

  @override
  int get hashCode => Object.hash(runtimeType, acct);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LRAcctImplCopyWith<_$LRAcctImpl> get copyWith =>
      __$$LRAcctImplCopyWithImpl<_$LRAcctImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) {
    return acct(this.acct);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) {
    return acct?.call(this.acct);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) {
    if (acct != null) {
      return acct(this.acct);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) {
    return acct(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) {
    return acct?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) {
    if (acct != null) {
      return acct(this);
    }
    return orElse();
  }
}

abstract class LRAcct implements LoginResult {
  const factory LRAcct(final Acct acct) = _$LRAcctImpl;

  Acct get acct;
  @JsonKey(ignore: true)
  _$$LRAcctImplCopyWith<_$LRAcctImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LRResetImplCopyWith<$Res> {
  factory _$$LRResetImplCopyWith(
          _$LRResetImpl value, $Res Function(_$LRResetImpl) then) =
      __$$LRResetImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LRResetImplCopyWithImpl<$Res>
    extends _$LoginResultCopyWithImpl<$Res, _$LRResetImpl>
    implements _$$LRResetImplCopyWith<$Res> {
  __$$LRResetImplCopyWithImpl(
      _$LRResetImpl _value, $Res Function(_$LRResetImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LRResetImpl implements LRReset {
  const _$LRResetImpl();

  @override
  String toString() {
    return 'LoginResult.reset()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LRResetImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) {
    return reset();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) {
    return reset?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) {
    return reset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) {
    return reset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(this);
    }
    return orElse();
  }
}

abstract class LRReset implements LoginResult {
  const factory LRReset() = _$LRResetImpl;
}

/// @nodoc
abstract class _$$LRRetryImplCopyWith<$Res> {
  factory _$$LRRetryImplCopyWith(
          _$LRRetryImpl value, $Res Function(_$LRRetryImpl) then) =
      __$$LRRetryImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LRRetryImplCopyWithImpl<$Res>
    extends _$LoginResultCopyWithImpl<$Res, _$LRRetryImpl>
    implements _$$LRRetryImplCopyWith<$Res> {
  __$$LRRetryImplCopyWithImpl(
      _$LRRetryImpl _value, $Res Function(_$LRRetryImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LRRetryImpl implements LRRetry {
  const _$LRRetryImpl();

  @override
  String toString() {
    return 'LoginResult.retry()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LRRetryImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) {
    return retry();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) {
    return retry?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) {
    if (retry != null) {
      return retry();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) {
    return retry(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) {
    return retry?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) {
    if (retry != null) {
      return retry(this);
    }
    return orElse();
  }
}

abstract class LRRetry implements LoginResult {
  const factory LRRetry() = _$LRRetryImpl;
}

/// @nodoc
abstract class _$$LRNothingImplCopyWith<$Res> {
  factory _$$LRNothingImplCopyWith(
          _$LRNothingImpl value, $Res Function(_$LRNothingImpl) then) =
      __$$LRNothingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LRNothingImplCopyWithImpl<$Res>
    extends _$LoginResultCopyWithImpl<$Res, _$LRNothingImpl>
    implements _$$LRNothingImplCopyWith<$Res> {
  __$$LRNothingImplCopyWithImpl(
      _$LRNothingImpl _value, $Res Function(_$LRNothingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LRNothingImpl implements LRNothing {
  const _$LRNothingImpl();

  @override
  String toString() {
    return 'LoginResult.nothing()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LRNothingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LoginChoice choice) choose,
    required TResult Function(Acct acct) acct,
    required TResult Function() reset,
    required TResult Function() retry,
    required TResult Function() nothing,
  }) {
    return nothing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LoginChoice choice)? choose,
    TResult? Function(Acct acct)? acct,
    TResult? Function()? reset,
    TResult? Function()? retry,
    TResult? Function()? nothing,
  }) {
    return nothing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LoginChoice choice)? choose,
    TResult Function(Acct acct)? acct,
    TResult Function()? reset,
    TResult Function()? retry,
    TResult Function()? nothing,
    required TResult orElse(),
  }) {
    if (nothing != null) {
      return nothing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LRChoose value) choose,
    required TResult Function(LRAcct value) acct,
    required TResult Function(LRReset value) reset,
    required TResult Function(LRRetry value) retry,
    required TResult Function(LRNothing value) nothing,
  }) {
    return nothing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LRChoose value)? choose,
    TResult? Function(LRAcct value)? acct,
    TResult? Function(LRReset value)? reset,
    TResult? Function(LRRetry value)? retry,
    TResult? Function(LRNothing value)? nothing,
  }) {
    return nothing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LRChoose value)? choose,
    TResult Function(LRAcct value)? acct,
    TResult Function(LRReset value)? reset,
    TResult Function(LRRetry value)? retry,
    TResult Function(LRNothing value)? nothing,
    required TResult orElse(),
  }) {
    if (nothing != null) {
      return nothing(this);
    }
    return orElse();
  }
}

abstract class LRNothing implements LoginResult {
  const factory LRNothing() = _$LRNothingImpl;
}
